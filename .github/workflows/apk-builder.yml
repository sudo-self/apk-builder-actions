name: APK Builder

on:
  repository_dispatch:
    types: [apk_build]
  workflow_dispatch:
    inputs:
      buildId:
        description: 'Build ID'
        required: true
        default: 'test-build-123'
      hostName:
        description: 'Host name'
        required: true
        default: 'example.com'
      name:
        description: 'App name'
        required: true
        default: 'Test App'
      launcherName:
        description: 'Launcher name'
        required: false
        default: 'Test App'
      themeColor:
        description: 'Theme color'
        required: false
        default: '#171717'
      themeColorDark:
        description: 'Theme color dark'
        required: false
        default: '#000000'
      backgroundColor:
        description: 'Background color'
        required: false
        default: '#FFFFFF'

jobs:
  build-apk:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: Checkout APK Builder repo
      uses: actions/checkout@v4
      
    - name: Checkout Template APK repo
      uses: actions/checkout@v4
      with:
        repository: sudo-self/template_apk
        token: ${{ secrets.GITHUB_TOKEN }}
        path: android-project
        
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'
        
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
      
    - name: Debug - Show received inputs
      run: |
        echo "=== Repository Dispatch Payload ==="
        echo "Build ID: ${{ github.event.client_payload.buildId }}"
        echo "Host Name: ${{ github.event.client_payload.hostName }}"
        echo "Launch URL: ${{ github.event.client_payload.launchUrl }}"
        echo "App Name: ${{ github.event.client_payload.name }}"
        echo "Launcher Name: ${{ github.event.client_payload.launcherName }}"
        echo "Theme Color: ${{ github.event.client_payload.themeColor }}"
        echo "Theme Color Dark: ${{ github.event.client_payload.themeColorDark }}"
        echo "Background Color: ${{ github.event.client_payload.backgroundColor }}"
        echo ""
        echo "=== Manual Workflow Inputs ==="
        echo "Build ID: ${{ github.event.inputs.buildId }}"
        echo "Host Name: ${{ github.event.inputs.hostName }}"
        echo "App Name: ${{ github.event.inputs.name }}"
        echo "Launcher Name: ${{ github.event.inputs.launcherName }}"
        echo "Theme Color: ${{ github.event.inputs.themeColor }}"
        echo "Theme Color Dark: ${{ github.event.inputs.themeColorDark }}"
        echo "Background Color: ${{ github.event.inputs.backgroundColor }}"
      
    - name: Customize Android Project
      env:
        BUILD_ID: ${{ github.event.client_payload.buildId || github.event.inputs.buildId }}
        HOST_NAME: ${{ github.event.client_payload.hostName || github.event.inputs.hostName }}
        LAUNCH_URL: ${{ github.event.client_payload.launchUrl || github.event.inputs.launchUrl || '/' }}
        APP_NAME: ${{ github.event.client_payload.name || github.event.inputs.name }}
        LAUNCHER_NAME: ${{ github.event.client_payload.launcherName || github.event.inputs.launcherName }}
        THEME_COLOR: ${{ github.event.client_payload.themeColor || github.event.inputs.themeColor || '#171717' }}
        THEME_COLOR_DARK: ${{ github.event.client_payload.themeColorDark || github.event.inputs.themeColorDark || '#000000' }}
        BACKGROUND_COLOR: ${{ github.event.client_payload.backgroundColor || github.event.inputs.backgroundColor || '#FFFFFF' }}
      run: |
        echo "Customizing Android project with:"
        echo "  BUILD_ID: $BUILD_ID"
        echo "  HOST_NAME: $HOST_NAME"
        echo "  LAUNCH_URL: $LAUNCH_URL"
        echo "  APP_NAME: $APP_NAME"
        echo "  LAUNCHER_NAME: $LAUNCHER_NAME"
        echo "  THEME_COLOR: $THEME_COLOR"
        echo "  THEME_COLOR_DARK: $THEME_COLOR_DARK"
        echo "  BACKGROUND_COLOR: $BACKGROUND_COLOR"
        
        # Construct full launch URL if only hostname provided
        if [ "$LAUNCH_URL" = "/" ] || [ -z "$LAUNCH_URL" ]; then
          LAUNCH_URL="https://$HOST_NAME/"
          echo "Generated LAUNCH_URL: $LAUNCH_URL"
        fi
        
        python scripts/customize-project.py

    - name: Verify Android Project Structure
      run: |
        cd android-project
        echo "=== Project Structure ==="
        find . -name "*.gradle" -o -name "AndroidManifest.xml" -o -name "*.properties" | head -20
        echo ""
        echo "=== App Module ==="
        ls -la app/ || echo "No app directory"
        echo ""
        echo "=== Gradle Wrapper ==="
        ls -la gradle/wrapper/ || echo "No gradle wrapper"

    - name: Fix File Permissions
      run: |
        cd android-project
        echo "=== Fixing file permissions ==="
        # Make gradlew executable
        if [ -f "gradlew" ]; then
          chmod +x gradlew
          echo "Made gradlew executable"
        else
          echo "gradlew not found"
        fi
        
        # Make other scripts executable
        find . -name "*.sh" -type f -exec chmod +x {} \; 2>/dev/null || echo "No shell scripts found"
        find . -name "*.py" -type f -exec chmod +x {} \; 2>/dev/null || echo "No Python scripts found"
        
        echo "=== Current permissions ==="
        ls -la gradlew 2>/dev/null || echo "gradlew not present"

    - name: Update Gradle Wrapper if Needed
      run: |
        cd android-project
        if [ -f "gradlew" ]; then
          echo "Updating Gradle wrapper to compatible version..."
          ./gradlew wrapper --gradle-version 8.11.1 --distribution-type all --no-daemon
        else
          echo "No gradlew found, using existing setup"
        fi

    - name: Build APK with Proper Configuration
      id: build-apk
      run: |
        cd android-project
        chmod +x gradlew
        
        echo "=== Cleaning Project ==="
        ./gradlew clean --no-daemon --stacktrace || echo "Clean failed but continuing"
        
        echo "=== Checking Dependencies ==="
        ./gradlew dependencies --configuration releaseRuntimeClasspath --no-daemon || echo "Dependency check completed"
        
        echo "=== Building APK ==="
        # Build with specific tasks for better control
        ./gradlew assembleRelease \
          --no-daemon \
          --stacktrace \
          --warning-mode all \
          --info \
          -Pandroid.injected.signing.store.file=$(pwd)/android.keystore \
          -Pandroid.injected.signing.store.password=123321 \
          -Pandroid.injected.signing.key.alias=android \
          -Pandroid.injected.signing.key.password=123321

    - name: Find All Built APKs
      id: find-apk
      run: |
        cd android-project
        
        echo "=== Searching for APK files ==="
        find . -name "*.apk" -type f | while read file; do
          echo "Found: $file ($(du -h "$file" | cut -f1))"
        done
        
        # Try multiple possible APK paths
        APK_PATHS=(
          "app/build/outputs/apk/release/app-release.apk"
          "app/build/outputs/apk/release/app-release-unsigned.apk" 
          "app/build/outputs/apk/release/*.apk"
          "app/build/outputs/apk/*/release/*.apk"
        )
        
        APK_PATH=""
        for path in "${APK_PATHS[@]}"; do
          if ls $path 1> /dev/null 2>&1; then
            APK_PATH=$(ls $path | head -1)
            echo "Using APK: $APK_PATH"
            break
          fi
        done
        
        if [ -z "$APK_PATH" ]; then
          echo "ERROR: No APK file found!"
          echo "Available files in build outputs:"
          find app/build/outputs -type f -name "*.apk" 2>/dev/null || echo "No APK files in outputs"
          exit 1
        fi
        
        echo "APK_PATH=$APK_PATH" >> $GITHUB_OUTPUT
        APK_SIZE=$(du -h "$APK_PATH" | cut -f1)
        echo "APK_SIZE=$APK_SIZE" >> $GITHUB_OUTPUT
        echo "Selected APK: $APK_PATH ($APK_SIZE)"

    - name: Verify APK Structure
      run: |
        cd android-project
        APK_PATH="${{ steps.find-apk.outputs.APK_PATH }}"
        
        echo "=== APK Analysis ==="
        echo "APK: $APK_PATH"
        
        # Check if APK is valid using aapt2
        export ANDROID_HOME="${{ env.ANDROID_HOME }}"
        AAPT2_PATH=$(find "$ANDROID_HOME" -name "aapt2" | head -1)
        
        if [ -n "$AAPT2_PATH" ] && [ -f "$APK_PATH" ]; then
          echo "=== Basic APK Info ==="
          $AAPT2_PATH dump badging "$APK_PATH" | head -10 || echo "aapt2 analysis failed"
        else
          echo "aapt2 not found, using file command"
          file "$APK_PATH" || echo "file command failed"
        fi
        
        # Check file type
        echo "=== File Type ==="
        file "$APK_PATH" || echo "Could not determine file type"

    - name: Sign APK with android.keystore
      id: sign-apk
      run: |
        cd android-project
        
        # Verify keystore exists and is valid
        if [ ! -f "android.keystore" ]; then
          echo "ERROR: android.keystore not found in project root"
          ls -la
          exit 1
        fi
        
        echo "=== Keystore Info ==="
        keytool -list -v -keystore android.keystore -storepass 123321 2>/dev/null | head -10 || echo "Could not read keystore details"
        
        echo "=== Signing APK ==="
        UNSIGNED_APK="${{ steps.find-apk.outputs.APK_PATH }}"
        SIGNED_APK="${UNSIGNED_APK%.apk}-signed.apk"
        
        # Set up Android SDK paths
        export ANDROID_HOME="${{ env.ANDROID_HOME }}"
        export ANDROID_SDK_ROOT="${{ env.ANDROID_SDK_ROOT }}"
        
        # Find apksigner (try multiple locations)
        APKSIGNER_PATH=$(find "$ANDROID_HOME" -name "apksigner" | head -1)
        if [ -z "$APKSIGNER_PATH" ]; then
          echo "ERROR: apksigner not found in Android SDK"
          find "$ANDROID_HOME" -name "apksigner*" | head -10
          exit 1
        fi
        
        echo "Using apksigner: $APKSIGNER_PATH"
        echo "Input APK: $UNSIGNED_APK"
        echo "Output APK: $SIGNED_APK"
        
        # Sign the APK with verbose output
        "$APKSIGNER_PATH" sign \
          --ks android.keystore \
          --ks-pass pass:123321 \
          --key-pass pass:123321 \
          --ks-key-alias android \
          --out "$SIGNED_APK" \
          --verbose \
          "$UNSIGNED_APK"
        
        # Verify the signature
        echo "=== Verifying Signature ==="
        "$APKSIGNER_PATH" verify --verbose "$SIGNED_APK"
        
        echo "SIGNED_APK_PATH=$SIGNED_APK" >> $GITHUB_OUTPUT
        echo "APK signed and verified successfully"

    - name: Verify Signed APK
      id: verify-apk
      run: |
        cd android-project
        
        SIGNED_APK="${{ steps.sign-apk.outputs.SIGNED_APK_PATH }}"
        echo "=== Verifying Signed APK ==="
        
        if [ ! -f "$SIGNED_APK" ]; then
          echo "ERROR: Signed APK not found at: $SIGNED_APK"
          echo "Available APK files:"
          find . -name "*.apk" -type f -exec ls -la {} \;
          exit 1
        fi
        
        # Check signed APK with aapt2 if available
        export ANDROID_HOME="${{ env.ANDROID_HOME }}"
        AAPT2_PATH=$(find "$ANDROID_HOME" -name "aapt2" | head -1)
        
        if [ -n "$AAPT2_PATH" ]; then
          echo "=== Signed APK Package Info ==="
          $AAPT2_PATH dump badging "$SIGNED_APK" | grep -E "(package|application|launchable)" || echo "Could not extract package info"
        fi
        
        SIGNED_SIZE=$(du -h "$SIGNED_APK" | cut -f1)
        echo "SIGNED_SIZE=$SIGNED_SIZE" >> $GITHUB_OUTPUT
        echo "Signed APK verified: $SIGNED_APK ($SIGNED_SIZE)"

    - name: Zipalign APK (Optimize)
      id: zipalign-apk
      run: |
        cd android-project
        
        SIGNED_APK="${{ steps.sign-apk.outputs.SIGNED_APK_PATH }}"
        ZIPPED_APK="${SIGNED_APK%.apk}-aligned.apk"
        
        export ANDROID_HOME="${{ env.ANDROID_HOME }}"
        ZIPALIGN_PATH=$(find "$ANDROID_HOME" -name "zipalign" | head -1)
        
        if [ -n "$ZIPALIGN_PATH" ]; then
          echo "=== Running zipalign ==="
          "$ZIPALIGN_PATH" -v -p 4 "$SIGNED_APK" "$ZIPPED_APK"
          
          if [ -f "$ZIPPED_APK" ]; then
            echo "Zipalign successful"
            echo "FINAL_APK_PATH=$ZIPPED_APK" >> $GITHUB_OUTPUT
          else
            echo "Zipalign failed, using signed APK"
            echo "FINAL_APK_PATH=$SIGNED_APK" >> $GITHUB_OUTPUT
          fi
        else
          echo "zipalign not found, using signed APK as-is"
          echo "FINAL_APK_PATH=$SIGNED_APK" >> $GITHUB_OUTPUT
        fi

    - name: Rename APK for User
      id: rename-apk
      run: |
        cd android-project
        
        FINAL_APK_PATH="${{ steps.zipalign-apk.outputs.FINAL_APK_PATH }}"
        APP_NAME="${{ github.event.client_payload.name || github.event.inputs.name }}"
        
        # Create a user-friendly filename (safe for filesystem)
        CLEAN_APP_NAME=$(echo "$APP_NAME" | tr ' ' '-' | tr -cd '[:alnum:]-._')
        FINAL_APK_NAME="${CLEAN_APP_NAME}-signed.apk"
        FINAL_APK_DIR="dist"
        
        mkdir -p "$FINAL_APK_DIR"
        FINAL_DEST_PATH="$FINAL_APK_DIR/$FINAL_APK_NAME"
        
        # Copy to final location
        cp "$FINAL_APK_PATH" "$FINAL_DEST_PATH"
        
        echo "FINAL_APK_PATH=$FINAL_DEST_PATH" >> $GITHUB_OUTPUT
        echo "FINAL_APK_NAME=$FINAL_APK_NAME" >> $GITHUB_OUTPUT
        echo "Renamed APK to: $FINAL_APK_NAME"

    - name: Final APK Verification
      run: |
        cd android-project
        
        FINAL_APK="${{ steps.rename-apk.outputs.FINAL_APK_PATH }}"
        echo "=== Final APK Verification ==="
        
        if [ ! -f "$FINAL_APK" ]; then
          echo "ERROR: Final APK not found at: $FINAL_APK"
          exit 1
        fi
        
        echo "Final APK: $FINAL_APK"
        echo "File size: $(du -h "$FINAL_APK" | cut -f1)"
        echo "File type: $(file "$FINAL_APK" || echo "unknown")"
        
        # Basic APK structure check
        if file "$FINAL_APK" | grep -q "Zip archive"; then
          echo "âœ“ APK is a valid ZIP archive"
          # Check for essential APK files
          if unzip -l "$FINAL_APK" | grep -q "AndroidManifest.xml"; then
            echo "âœ“ Contains AndroidManifest.xml"
          else
            echo "âš  Missing AndroidManifest.xml"
          fi
          if unzip -l "$FINAL_APK" | grep -q "classes.dex"; then
            echo "âœ“ Contains classes.dex"
          else
            echo "âš  Missing classes.dex"
          fi
          if unzip -l "$FINAL_APK" | grep -q "resources.arsc"; then
            echo "âœ“ Contains resources.arsc"
          else
            echo "âš  Missing resources.arsc"
          fi
        else
          echo "âŒ Not a valid ZIP archive"
          exit 1
        fi
        
        echo "Final APK verification completed successfully"

    - name: Upload Signed APK Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ github.event.client_payload.name || github.event.inputs.name }}-APK
        path: android-project/${{ steps.rename-apk.outputs.FINAL_APK_PATH }}
        retention-days: 7
        if-no-files-found: error
        
    - name: Create Build Summary
      run: |
        echo "### ðŸ“± APK Build Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**âœ… Build Completed Successfully!**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Build Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- App Name: ${{ github.event.client_payload.name || github.event.inputs.name }}" >> $GITHUB_STEP_SUMMARY
        echo "- Domain: ${{ github.event.client_payload.hostName || github.event.inputs.hostName }}" >> $GITHUB_STEP_SUMMARY
        echo "- Build ID: ${{ github.event.client_payload.buildId || github.event.inputs.buildId }}" >> $GITHUB_STEP_SUMMARY
        echo "- APK File: ${{ steps.rename-apk.outputs.FINAL_APK_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- Size: ${{ steps.find-apk.outputs.APK_SIZE }} â†’ ${{ steps.verify-apk.outputs.SIGNED_SIZE }} (signed)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**ðŸ”§ Build Quality:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Signed with release key" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Zipaligned (optimized)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Valid APK structure" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Contains essential Android components" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**ðŸ“¥ Installation Instructions:**" >> $GITHUB_STEP_SUMMARY
        echo "1. **Download** the APK from the artifacts section below" >> $GITHUB_STEP_SUMMARY
        echo "2. **Enable installation** from unknown sources in Android Settings â†’ Security" >> $GITHUB_STEP_SUMMARY
        echo "3. **Open** the downloaded APK file to install" >> $GITHUB_STEP_SUMMARY
        echo "4. **Launch** the app from your home screen" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**ðŸ”‘ Signing Information:**" >> $GITHUB_STEP_SUMMARY
        echo "- Key Alias: \`android\`" >> $GITHUB_STEP_SUMMARY
        echo "- Keystore Password: \`123321\`" >> $GITHUB_STEP_SUMMARY
        echo "- Key Password: \`123321\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "> âš ï¸ **Troubleshooting:**" >> $GITHUB_STEP_SUMMARY
        echo "> - If you get 'App not installed', ensure 'Install from Unknown Sources' is enabled" >> $GITHUB_STEP_SUMMARY
        echo "> - Make sure you're downloading the actual APK file, not the GitHub artifact ZIP" >> $GITHUB_STEP_SUMMARY
        echo "> - The APK should install like any regular Android application" >> $GITHUB_STEP_SUMMARY
        echo "> - Tested with Android 5.0+ (API 21+)" >> $GITHUB_STEP_SUMMARY
        
    - name: Notify Success via Webhook
      if: success() && env.WEBHOOK_URL
      run: |
        python scripts/notify-webhook.py success
      env:
        WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        BUILD_ID: ${{ github.event.client_payload.buildId || github.event.inputs.buildId }}
        ARTIFACT_NAME: ${{ steps.rename-apk.outputs.FINAL_APK_NAME }}
        
    - name: Notify Failure via Webhook
      if: failure() && env.WEBHOOK_URL
      run: |
        python scripts/notify-webhook.py failure
      env:
        WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        BUILD_ID: ${{ github.event.client_payload.buildId || github.event.inputs.buildId }}


